# Interactive container info viewer for klogs
klogs_container_info() {
  local pod="$1"
  local ns="$2"
  local container="$3"

  # ANSI color codes
  local RESET=$'\033[0m'
  local BOLD=$'\033[1m'
  local CYAN=$'\033[1;36m'
  local GREEN=$'\033[1;32m'
  local YELLOW=$'\033[1;33m'
  local MAGENTA=$'\033[1;35m'
  local BLUE=$'\033[1;34m'
  local RED=$'\033[1;31m'

    # Get pod JSON
    local pod_json
    pod_json=$(kubectl get pod "$pod" -n "$ns" -o json 2>/dev/null)
    # Container info block
    echo -e "\n${CYAN}========================================${RESET}"
    echo -e "${CYAN}Container Info:${RESET} ${GREEN}${container}${RESET}"
    echo -e "Pod: ${CYAN}${pod}${RESET}"
    echo -e "Namespace: ${CYAN}${ns}${RESET}"
    echo -e "${CYAN}========================================${RESET}"
    # Status
    local status ready restart_count started_at image image_id container_id ports mounts pod_ip node
    status=$(echo "$pod_json" | jq -r '.status.phase // "N/A"')
    ready=$(echo "$pod_json" | jq -r '.status.containerStatuses[] | select(.name=="'$container'") | .ready // "N/A"')
    restart_count=$(echo "$pod_json" | jq -r '.status.containerStatuses[] | select(.name=="'$container'") | .restartCount // "N/A"')
    started_at=$(echo "$pod_json" | jq -r '.status.containerStatuses[] | select(.name=="'$container'") | .state.running.startedAt // .state.terminated.finishedAt // "N/A"')
    image=$(echo "$pod_json" | jq -r '.spec.containers[] | select(.name=="'$container'") | .image // "N/A"')
    image_id=$(echo "$pod_json" | jq -r '.status.containerStatuses[] | select(.name=="'$container'") | .imageID // "N/A"')
    container_id=$(echo "$pod_json" | jq -r '.status.containerStatuses[] | select(.name=="'$container'") | .containerID // "N/A"')
    ports=$(echo "$pod_json" | jq -r '.spec.containers[] | select(.name=="'$container'") | .ports[]? | ""+(.containerPort|tostring)+"/"+(.protocol) ' | paste -sd ", " -)
    mounts=$(echo "$pod_json" | jq -r '.spec.containers[] | select(.name=="'$container'") | .volumeMounts[]? | ""+.mountPath+" (from "+.name+", "+(.readOnly|tostring)+")"' | paste -sd ", " -)
    pod_ip=$(echo "$pod_json" | jq -r '.status.podIP // "N/A"')
    node=$(echo "$pod_json" | jq -r '.spec.nodeName // "N/A"')
    # Output with color
    echo -e "Status: ${GREEN}${status}${RESET}"
    echo -e "Ready: ${GREEN}${ready}${RESET}"
    echo -e "Restart Count: ${YELLOW}${restart_count}${RESET}"
    echo -e "Started At: ${BOLD}${started_at}${RESET}"
    echo -e ""
    echo -e "Image: ${MAGENTA}${image}${RESET}"
    echo -e "Image ID: ${MAGENTA}${image_id}${RESET}"
    echo -e "Container ID: ${CYAN}${container_id}${RESET}"
    echo -e ""
    echo -e "Ports: ${YELLOW}${ports:-N/A}${RESET}"
    echo -e ""
    echo -e "Mounts: ${CYAN}${mounts:-N/A}${RESET}"
    echo -e ""
    echo -e "Pod IP: ${CYAN}${pod_ip}${RESET}"
    echo -e "Node: ${CYAN}${node}${RESET}"
    echo -e "${CYAN}========================================${RESET}"

  # Interactive menu for more details
  while true; do
    echo -e "\n${BLUE}More Details (choose one to view, or exit):${RESET}"
    echo -e "${YELLOW}1.${RESET} View Pod Conditions"
    echo -e "${YELLOW}2.${RESET} View Volumes"
    echo -e "${YELLOW}3.${RESET} View Events"
    echo -e "${YELLOW}4.${RESET} View Environment Variables"
    echo -e "${RED}5.${RESET} Exit"
    if [ -n "${ZSH_VERSION:-}" ]; then
      read "detail_choice?Enter the number of the detail to view (or 5 to exit): "
    else
      printf "Enter the number of the detail to view (or 5 to exit): "
      read -r detail_choice
    fi
    case "$detail_choice" in
      1)
        echo -e "\n${CYAN}Pod Conditions:${RESET}"
        kubectl get pod "$pod" -n "$ns" -o json | jq -r '.status.conditions[] | "- Type: \(.type)\n  Status: \(.status)\n  Reason: \(.reason // "N/A")\n  Message: \(.message // "N/A")\n"' 2>/dev/null
        ;;
      2)
        echo -e "\n${CYAN}Volumes:${RESET}"
        kubectl get pod "$pod" -n "$ns" -o json | jq -r '
          .spec.volumes[] | 
          "- Name: \(.name)\n  Type: \(. | del(.name) | keys[0])" + 
          if (.configMap) then "\n  ConfigMap: \(.configMap.name)" + (if (.configMap.optional) then " (optional)" else "" end) 
          elif (.secret) then "\n  Secret: \(.secret.secretName)" + (if (.secret.optional) then " (optional)" else "" end)
          elif (.projected) then "\n  Projected: " + (.projected.sources | map(. | keys[0]) | join(", "))
          else "" end
        ' 2>/dev/null
        ;;
      3)
        echo -e "\n${CYAN}Events:${RESET}"
        kubectl describe pod "$pod" -n "$ns" | sed -n '/^Events:/,/^$/p' | tail -n +3 | awk 'NF {print "  " $1 " " $2 " " $4 ": " $5}' | head -10 2>/dev/null || echo "  No events found"
        ;;
      4)
        echo -e "\n${CYAN}Environment Variables:${RESET}"
        # Get environment variables and decode secret values
        kubectl get pod "$pod" -n "$ns" -o json | jq -r '.spec.containers[] | select(.name=="'"$selected_container"'") | .env[] | if .value then "\(.name)=\(.value)" else "\(.name)=secret://\(.valueFrom.secretKeyRef.name)/\(.valueFrom.secretKeyRef.key)" end' 2>/dev/null | while IFS='=' read -r var_name var_value; do
          if [[ "$var_value" == secret://* ]]; then
            # Extract secret name and key
            secret_info="${var_value#secret://}"
            secret_name="${secret_info%/*}"
            secret_key="${secret_info#*/}"
            # Fetch the actual secret value
            secret_value=$(kubectl get secret "$secret_name" -n "$ns" -o jsonpath="{.data.$secret_key}" 2>/dev/null | base64 -d 2>/dev/null || echo "ERROR")
            echo "  - $var_name: $secret_value (from secret $secret_name)"
          else
            echo "  - $var_name: $var_value"
          fi
        done || echo "  No environment variables found"
        ;;
      5)
        echo -e "${RED}Exiting container info view.${RESET}"
        break
        ;;
      *)
        echo -e "${RED}Invalid choice. Please enter a number from 1 to 5.${RESET}"
        ;;
    esac
  done
}
# Quick navigation aliases for dotfiles 
alias df='cd ~/dotfiles'
alias dotfiles='cd ~/dotfiles'

# Stream Kubernetes pod logs for an app.
klogs() {
  # Defaults
  local KLOG_NO_COLOR=0
  local KLOG_LINES=""
  local KLOG_SEARCH_TERMS=()
  local KLOG_APP=""
  local KLOG_NAMESPACE=""

  # Parse all arguments, flags can be anywhere
  while [ "$#" -gt 0 ]; do
    echo "[DEBUG] Parsing arg: $1"
    case "$1" in
      -n|--no-color)
        KLOG_NO_COLOR=1
        shift
        ;;
      -ns|--namespace)
        shift
        if [ -n "$1" ]; then
          KLOG_NAMESPACE="$1"
          shift
        else
          echo "Error: --namespace requires an argument"
          return 1
        fi
        ;;
      --namespace=*)
        KLOG_NAMESPACE="${1#--namespace=}"
        shift
        ;;
      -l|--lines)
        shift
        if [ -n "$1" ] && printf '%s' "$1" | grep -qE '^[0-9]+$'; then
          KLOG_LINES="$1"
          shift
        else
          echo "Error: --lines requires a numeric argument"
          return 1
        fi
        ;;
      --lines=*)
        KLOG_LINES="${1#--lines=}"
        shift
        ;;
      -s|--search)
        shift
        if [ -n "$1" ]; then
          KLOG_SEARCH_TERMS+=("$1")
          shift
        else
          echo "Error: --search requires an argument"
          return 1
        fi
        ;;
      --search=*)
        KLOG_SEARCH_TERMS+=("${1#--search=}")
        shift
        ;;
      -h|--help)
        cat <<EOF
klogs - Stream Kubernetes pod logs for an app, with interactive pod selection and advanced filtering.

USAGE:
  klogs [ -n | --no-color ] [ -ns <namespace> | --namespace <namespace> ] [ -l <num> | --lines <num> ] [ -s <term> | --search <term> ]... [<app-name>]

FLAGS:
  -n, --no-color         Disable colored output in pod list and logs
  -ns <namespace>, --namespace <namespace>  Limit search to specified namespace (default: all namespaces)
  -l <num>, --lines <num>        Tail last N lines before streaming logs (default: all)
  -s <term>, --search <term> Filter logs for TERM (case-insensitive, fixed string). Repeat for multiple terms.
  -h, --help             Show this help guide

ARGUMENTS:
  <app-name>             Optional. Substring to match pod names (e.g., sso-proxy). If omitted, shows all pods across all namespaces.

EXAMPLES:
  klogs                                 # Show all pods across all namespaces
  klogs -ns dev                         # Show all pods in 'dev' namespace only
  klogs sso-proxy                       # Stream all logs for pods matching 'sso-proxy'
  klogs -ns qa sso-proxy                # Stream logs for 'sso-proxy' pods in 'qa' namespace
  klogs -l 200 sso-proxy                # Tail last 200 lines, then follow logs
  klogs -s error sso-proxy              # Show only log lines containing 'error'
  klogs -s error -s warning sso-proxy   # Show log lines containing 'error' OR 'warning'
  klogs -n -l 100 -s foo sso-proxy      # Disable color, tail 100 lines, filter 'foo'
  klogs sso-proxy 200                   # (Legacy) Tail 200 lines for 'sso-proxy'
  klogs sso-proxy error                 # (Legacy) Filter logs for 'error'

LOG DATA EXAMPLE:
  10.115.155.14 - - [10/Oct/2025:17:01:00 +0000] "GET /api/status HTTP/1.1" 200 60 "-" "curl/7.61.1" "-"

SEARCHING FOR LOGS FROM A SPECIFIC HOUR ON A DATE:
  To show all logs from 17:00 on 10/Oct/2025:
    klogs sso-proxy -s 10/Oct/2025:17
  To show logs from multiple hours or dates:
    klogs sso-proxy -s 10/Oct/2025:17 -s 10/Oct/2025:18

INTERACTIVE POD SELECTION:
  - Lists all pods matching <app-name> in specified namespace (or all namespaces if none specified), or all pods if no <app-name> provided
  - Shows pod info in a table (unless --no-color)
  - Prompts for pod selection by number

LOG STREAMING:
  - Streams logs for the selected pod
  - If --lines is set, tails last N lines before following
  - If --search is set, filters logs for TERM(s) (case-insensitive)
  - Color highlighting for TERM(s) if color enabled

TROUBLESHOOTING:
  - If no pods are found, check your app name or namespace
  - If you see 'No pods found', verify kubectl context and permissions
  - For very large logs, use --lines to limit output

TIPS:
  - Flags can appear before or after <app-name>
  - Works in both zsh and bash
  - Backwards-compatible with simple forms: klogs app 200, klogs app error
  - Use --no-color for piping output to files or other tools

EOF
        return 0
        ;;
      --)
        shift
        break
        ;;
      -* )
        echo "Unknown option: $1"
        return 1
        ;;
      *)
        if [ -z "$KLOG_APP" ]; then
          KLOG_APP="$1"
          shift
        elif [ -z "$KLOG_LINES" ] && printf '%s' "$1" | grep -qE '^[0-9]+$'; then
          KLOG_LINES="$1"
          shift
        elif [ -z "$KLOG_SEARCH_TERM" ]; then
          KLOG_SEARCH_TERM="$1"
          shift
        else
          shift
        fi
        ;;
    esac
  done

  echo "[DEBUG] After flag parsing: KLOG_NO_COLOR=$KLOG_NO_COLOR, KLOG_NAMESPACE=$KLOG_NAMESPACE, KLOG_LINES=$KLOG_LINES, KLOG_SEARCH_TERM=$KLOG_SEARCH_TERM, app=\"$KLOG_APP\""
  if [ -z "$KLOG_APP" ]; then
    if [ -n "$KLOG_NAMESPACE" ]; then
      echo "No app name provided - showing all pods in namespace '$KLOG_NAMESPACE'..."
    else
      echo "No app name provided - showing all pods across all namespaces..."
    fi
  fi

  # Colors (zsh/bash compatible) - only set when coloring enabled
  if [ "$KLOG_NO_COLOR" -eq 0 ]; then
    local RESET=$'\033[0m'
    local BOLD=$'\033[1m'
    local CYAN=$'\033[36m'    # namespace
    local GREEN=$'\033[32m'   # pod name
    local YELLOW=$'\033[33m'  # ready/status
    local HEADER_COLOR=$'\033[97m'
  else
    local RESET=''
    local BOLD=''
    local CYAN=''
    local GREEN=''
    local YELLOW=''
    local HEADER_COLOR=''
  fi

  # Get pods output - filter by pod name if provided, otherwise show all
  if [ -n "$KLOG_NAMESPACE" ]; then
    if [ -n "$KLOG_APP" ]; then
      pods_raw=$(kubectl get pods -n "$KLOG_NAMESPACE" | grep -E "^NAME|$KLOG_APP" | column -t 2>/dev/null)
    else
      pods_raw=$(kubectl get pods -n "$KLOG_NAMESPACE" | column -t 2>/dev/null)
    fi
  else
    if [ -n "$KLOG_APP" ]; then
      pods_raw=$(kubectl get pods --all-namespaces | grep -E "^NAMESPACE|$KLOG_APP" | column -t 2>/dev/null)
    else
      pods_raw=$(kubectl get pods --all-namespaces | column -t 2>/dev/null)
    fi
  fi
  if [ -z "$pods_raw" ]; then
    if [ -n "$KLOG_NAMESPACE" ]; then
      echo "No pods found matching name: $KLOG_APP in namespace: $KLOG_NAMESPACE."
    else
      echo "No pods found matching name: $KLOG_APP."
    fi
    return 1
  fi

  header=$(echo "$pods_raw" | head -n 1)
  pods=$(echo "$pods_raw" | tail -n +2)

  pod_lines=()
  while IFS= read -r line; do
    [[ -n "$line" ]] && pod_lines+=("$line")
  done <<< "$pods"

  if [ ${#pod_lines[@]} -eq 0 ]; then
    if [ -n "$KLOG_NAMESPACE" ]; then
      echo "No pods found matching name: $KLOG_APP in namespace: $KLOG_NAMESPACE."
    else
      echo "No pods found matching name: $KLOG_APP."
    fi
    return 1
  fi

  # Color header labels (preserve spacing)
  if [ -n "$KLOG_NAMESPACE" ]; then
    # When using specific namespace, header is: NAME READY STATUS RESTARTS AGE
    colored_header=$(printf "%s" "$header" | sed -E \
      -e "s/\bNAME\b/${BOLD}${GREEN}&${RESET}/g" \
      -e "s/\bREADY\b/${BOLD}${YELLOW}&${RESET}/g" \
      -e "s/\bSTATUS\b/${BOLD}${YELLOW}&${RESET}/g")
  else
    # When using --all-namespaces, header is: NAMESPACE NAME READY STATUS RESTARTS AGE
    colored_header=$(printf "%s" "$header" | sed -E \
      -e "s/\bNAMESPACE\b/${BOLD}${CYAN}&${RESET}/g" \
      -e "s/\bNAME\b/${BOLD}${GREEN}&${RESET}/g" \
      -e "s/\bREADY\b/${BOLD}${YELLOW}&${RESET}/g" \
      -e "s/\bSTATUS\b/${BOLD}${YELLOW}&${RESET}/g")
  fi

  printf "\n%-4s %s\n" "Idx" "$colored_header"
  # Iterate safely over indices
  i=1
  for raw_line in "${pod_lines[@]}"; do
    # Preserve the exact spacing between columns by capturing separators.
    if [ -n "$KLOG_NAMESPACE" ]; then
      # When using specific namespace, format is: NAME READY STATUS RESTARTS AGE
      # Color NAME and READY columns
      colored_line=$(printf "%s" "$raw_line" | sed -E \
        -e "s/^([[:space:]]*)([^[:space:]]+)([[:space:]]+)([^[:space:]]+)(.*)$/\\1${GREEN}\\2${RESET}\\3${YELLOW}\\4${RESET}\\5/")
    else
      # When using --all-namespaces, format is: NAMESPACE NAME READY STATUS RESTARTS AGE
      # Color NAMESPACE and NAME columns
      colored_line=$(printf "%s" "$raw_line" | sed -E \
        -e "s/^([[:space:]]*)([^[:space:]]+)([[:space:]]+)([^[:space:]]+)(.*)$/\\1${CYAN}\\2${RESET}\\3${GREEN}\\4${RESET}\\5/")
    fi
    printf "[%-2d] %s\n" "$i" "$colored_line"
    i=$((i+1))
  done

  # Prompt for selection in a shell-compatible way. Use zsh-style prompt when
  # running under zsh, otherwise fall back to a POSIX read prompt so this
  # function works both in zsh and bash.
  if [ -n "${ZSH_VERSION:-}" ]; then
    read "idx?Enter the number of the pod: "
  else
    printf "Enter the number of the pod: "
    read -r idx
  fi
  if ! [[ "$idx" =~ ^[0-9]+$ ]]; then
    echo "Please enter a valid number."
    return 1
  fi
  if [ "$idx" -lt 1 ] || [ "$idx" -gt ${#pod_lines[@]} ]; then
    echo "Please select a valid pod number."
    return 1
  fi

  # zsh arrays are 1-based while bash arrays are 0-based. Select the
  # appropriate element depending on the running shell.
  if [ -n "${ZSH_VERSION:-}" ]; then
    selected="${pod_lines[$idx]}"
  else
    selected="${pod_lines[$((idx-1))]}"
  fi
  
  echo "[DEBUG] selected line: '$selected'"
  
  # Remove the [number] prefix from the selected line before parsing
  selected=$(echo "$selected" | sed 's/^\[[0-9]*\] //')
  
  echo "[DEBUG] selected line after stripping prefix: '$selected'"
  
  # Parse pod name and namespace based on whether we're using all namespaces or a specific one
  if [ -n "$KLOG_NAMESPACE" ]; then
    # When using specific namespace, format is: NAME READY STATUS RESTARTS AGE
    pod=$(echo "$selected" | awk '{print $1}')
    ns="$KLOG_NAMESPACE"
  else
    # When using --all-namespaces, format is: NAMESPACE NAME READY STATUS RESTARTS AGE
    ns=$(echo "$selected" | awk '{print $1}')
    pod=$(echo "$selected" | awk '{print $2}')
  fi

  echo "[DEBUG] parsed: ns='$ns', pod='$pod'"

  if [ -z "$ns" ] || [ -z "$pod" ]; then
    echo "Invalid selection."
    return 1
  fi

  # Get container names for the selected pod
  if [ -n "${ZSH_VERSION:-}" ]; then
    typeset -a container_names
    container_names=( $(kubectl get pod "$pod" -n "$ns" -o jsonpath='{.spec.containers[*].name}') )
  else
    local container_names=( $(kubectl get pod "$pod" -n "$ns" -o jsonpath='{.spec.containers[*].name}') )
  fi
  echo "[DEBUG] container_names: ${container_names[@]}"
  selected_container="${container_names[0]}"
  if [ ${#container_names[@]} -gt 1 ]; then
    echo "\nThis pod has multiple containers:"
    idx=1
    for name in "${container_names[@]}"; do
      printf "[%d] %s\n" "$idx" "$name"
      idx=$((idx+1))
    done
    echo ""
    echo "Choose an action:"
    echo "[L] View logs for a container"
    echo "[I] View info about a container"
    if [ -n "${ZSH_VERSION:-}" ]; then
      read "action?Enter L for logs or I for info (default L): "
    else
      printf "Enter L for logs or I for info (default L): "
      read -r action
    fi
    action="${action:-L}"
    if [[ "$action" =~ ^[Ii]$ ]]; then
      if [ -n "${ZSH_VERSION:-}" ]; then
        read "cidx?Enter the number of the container to view info (default 1): "
      else
        printf "Enter the number of the container to view info (default 1): "
        read -r cidx
      fi
      echo "[DEBUG] cidx: $cidx"
      if [[ "$cidx" =~ ^[0-9]+$ ]] && [ "$cidx" -ge 1 ] && [ "$cidx" -le ${#container_names[@]} ]; then
        idx=1
        for name in "${container_names[@]}"; do
          if [ "$idx" -eq "$cidx" ]; then
            selected_container="$name"
            break
          fi
          idx=$((idx+1))
        done
      fi
      echo "[DEBUG] selected_container: $selected_container"
      klogs_container_info "$pod" "$ns" "$selected_container"
      return 0
    fi
    if [ -n "${ZSH_VERSION:-}" ]; then
      read "cidx?Enter the number of the container to view logs (default 1): "
    else
      printf "Enter the number of the container to view logs (default 1): "
      read -r cidx
    fi
    echo "[DEBUG] cidx: $cidx"
    if [[ "$cidx" =~ ^[0-9]+$ ]] && [ "$cidx" -ge 1 ] && [ "$cidx" -le ${#container_names[@]} ]; then
      idx=1
      for name in "${container_names[@]}"; do
        if [ "$idx" -eq "$cidx" ]; then
          selected_container="$name"
          break
        fi
        idx=$((idx+1))
      done
    fi
    echo "[DEBUG] selected_container: $selected_container"
  fi

  # Build kubectl command and optionally filter by search term using grep.
  if [ -n "$KLOG_LINES" ]; then
    kub_cmd=(kubectl logs -n "$ns" "$pod" -c "$selected_container" --tail="$KLOG_LINES" -f)
    echo "Streaming last $KLOG_LINES lines for pod $pod (container $selected_container) in namespace $ns..."
  else
    kub_cmd=(kubectl logs -n "$ns" "$pod" -c "$selected_container" -f)
    echo "Streaming all logs for pod $pod (container $selected_container) in namespace $ns..."
  fi

  if [ ${#KLOG_SEARCH_TERMS[@]} -gt 0 ]; then
    # Build grep arguments for all search terms
    grep_args=(--line-buffered -i -F)
    if [ "$KLOG_NO_COLOR" -eq 0 ]; then
      grep_args+=(--color=always)
    fi
    for term in "${KLOG_SEARCH_TERMS[@]}"; do
      grep_args+=(-e "$term")
    done
    "${kub_cmd[@]}" | grep "${grep_args[@]}"
  else
    "${kub_cmd[@]}"
  fi
}

# Function to check dotfiles status (git and Brewfile)
_check_dotfiles_status() {
  local show_success="${1:-false}"
  local in_dotfiles_dir="${2:-false}"
  local check_session_warn="${3:-false}"
  
  if [ "$in_dotfiles_dir" = "false" ]; then
    cd ~/dotfiles
  fi
  
  local issues_found=false
  
  if [[ -d ".git" ]]; then
    changes=$(git status --porcelain | wc -l)
    changes="${changes##*( )}"
    changes="${changes%%*( )}"
    if [ "$changes" -gt 0 ]; then
      # Only show if not checking session warning, or if we haven't warned in this session
      if [ "$check_session_warn" = "false" ] || [[ "$_DOTFILES_RELOAD_WARN" != "$$" ]]; then
        print -P "%F{yellow} $changes uncommitted change(s) in ~/dotfiles. Use 'dotpush'.%f"
        issues_found=true
      fi
    fi
  fi
  
  if ! brew bundle check --file="$HOME/dotfiles/Brewfile" &>/dev/null; then
    print -P "%F{yellow} Your Brewfile is out of sync with installed packages.%f"
    print -P "%F{cyan} Use 'brewupdate' to update your Brewfile, run 'brew outdated' to see what is outdated.%f"
    issues_found=true
  fi
  
  if [ "$show_success" = "true" ] && [ "$issues_found" = "false" ]; then
    print -P "%F{green} âœ“ Dotfiles are up to date - no uncommitted changes and Brewfile is in sync.%f"
  fi
  
  if [ "$in_dotfiles_dir" = "false" ]; then
    cd - > /dev/null
  fi
  
  return $([ "$issues_found" = "true" ] && echo 1 || echo 0)
}

# Check dotfiles status - shows git and Brewfile warnings if needed
alias df-check='_check_dotfiles_status true false'

# Show what changes would be committed in dotfiles using smart commit message
alias df-diff='cd ~/dotfiles && echo "=== Git Status ===" && git status --short && echo && echo "=== Proposed Commit Message ===" && (git genmsg) && cd -'
# Custom Aliases for Zsh

# quick alias to add, commit, and push all changes in dotfiles
alias dotpush='cd ~/dotfiles && git genmsg --commit --all && git push && cd -'

# preview the commit message that dotpush would use without committing
alias dotpush-dryrun='cd ~/dotfiles && git genmsg && cd -'

# quick alias to update Brewfile with current Homebrew/cask/extensions
# Usage: Run 'brewupdate' to update and overwrite Brewfile with your current setup
alias brewupdate='brew update && brew upgrade && brew bundle dump --file=~/dotfiles/Brewfile --force'

## aliases
alias ip='ipconfig getifaddr en0' # get local IP address
## 1Password ssh-agent aliases
# list ssh keys added to the 1Password ssh-agent
alias 1pass-ssh-list='SSH_AUTH_SOCK=~/Library/Group\ Containers/2BUA8C4S2C.com.1password/t/agent.sock ssh-add -l'
# open the 1Password ssh-agent config file
alias 1pass-ssh-config='open ~/.config/1Password/ssh/agent.toml'

# GPG key management
alias gpg-list='gpg --list-secret-keys --keyid-format LONG'
alias gpg-list-all='gpg --list-keys --keyid-format LONG'
alias gpg-github='_gpg_github_format'
alias gpg-gitlab='_gpg_gitlab_format'
alias gpg-find='_gpg_find'
alias gpg-export='_gpg_export'
alias gpg-fingerprint='gpg --fingerprint'

# GPG helper functions
_gpg_github_format() {
    gpg --list-secret-keys --keyid-format LONG | awk '
    /^sec/ {
        # Extract key ID from sec line
        split($2, parts, "/")
        keyid = parts[2]
        stored_keyid = keyid
    }
    /^uid/ {
        # Extract email from uid line and print first with light blue color
        match($0, /<[^>]+>/)
        echo "[DEBUG] Presenting options for commit_msg: $commit_msg"
        if (RSTART) {
            email = substr($0, RSTART+1, RLENGTH-2)
            printf "Email address: \033[94m%s\033[0m\n", email
            print "Key ID: " stored_keyid
        }
        echo "[DEBUG] User selected: $choice"
    }
    /^ssb/ {
        # Extract subkey ID from ssb line
        split($2, parts, "/")
        subkeyid = parts[2]
        print "Subkeys: " subkeyid
        print ""  # Empty line between keys
    }'
}

_gpg_gitlab_format() {
    gpg --list-secret-keys --with-subkey-fingerprints --keyid-format LONG | awk '
    BEGIN { 
        main_fingerprint = ""
        email = ""
        subkey_fingerprints = ""
        processing_main = 0
    }
    /^sec/ {
        processing_main = 1
    }
    /^uid/ {
        # Extract email from uid line
        match($0, /<[^>]+>/)
        if (RSTART) {
            email = substr($0, RSTART+1, RLENGTH-2)
        }
        processing_main = 0
    }
    /^ssb/ {
        processing_main = 0
    }
    /^      [A-F0-9]{40}$/ {
        # This is a fingerprint line (40 hex characters)
        if (processing_main) {
            main_fingerprint = $1
            processing_main = 0
        } else {
            # This is a subkey fingerprint
            if (subkey_fingerprints == "") {
                subkey_fingerprints = $1
            } else {
                subkey_fingerprints = subkey_fingerprints "\n" $1
            }
        }
    }
    END {
        if (email != "" && main_fingerprint != "") {
            printf "Email address: \033[94m%s\033[0m\n", email
            print "Key ID: " main_fingerprint
            if (subkey_fingerprints != "") {
                print "Subkeys: " subkey_fingerprints
            }
            print ""
        }
    }'
}

_gpg_find() {
    if [ $# -eq 0 ]; then
        echo "Usage: gpg-find <email|keyid|name>"
        return 1
    fi
    echo "Searching for: $1"
    gpg --list-secret-keys --keyid-format LONG | grep -i -A 3 -B 1 "$1"
}

_gpg_export() {
    if [ $# -eq 0 ]; then
        echo "Usage: gpg-export <keyid>"
        echo "This will export the public key for adding to GitHub/services"
        return 1
    fi
    echo "Public key for $1:"
    echo "=========================="
    gpg --armor --export "$1"
}

## copilot aliases
# alias to show directory info, git status, and git directories
alias info='echo "Current directory: $(pwd)"; echo; if git rev-parse --is-inside-work-tree &>/dev/null; then echo "This directory is a git repository."; else echo "This directory is NOT a git repository."; fi; echo; echo "Other .git directories under this tree:"; find . -type d -name .git | tee >(wc -l | awk '\''{print "Total: " $1}'\'')'

## ssh aliases
alias ssh-bitbucket="ssh bitbucket.org"
alias ssh-github="ssh github.com"
alias ssh-jenkins="ssh jenkins.premisehealth.com"
alias ssh-extract-api-dev="ssh d-ap-l-extract-02.premisehealth.com"
alias ssh-extract-api-qa="ssh q-ap-l-extract-01.premisehealth.com"
alias ssh-extract-api-prod="ssh p-ap-l-extract-02.premisehealth.com"
alias ssh-extract-db-dev="ssh d-db-tal-01.premisehealth.com"
alias ssh-extract-db-qa="ssh q-db-tal-01.premisehealth.com"
alias ssh-extract-db-prod="ssh p-db-tal-01.premisehealth.com"
alias ssh-paid-web-uat="ssh c-ap-l-paid-01.premisehealth.com"
alias ssh-paid-web-prod="ssh p-ap-l-paid-01.premisehealth.com"
alias ssh-paid-api-uat="ssh c-ap-l-paid-01.premisehealth.com"
alias ssh-paid-api-prod="ssh p-ap-l-paid-01.premisehealth.com"
alias ssh-paid-db-dev="ssh d-db-ph-02.dev-prem-health.com"
alias ssh-paid-db-qa="ssh q-db-ph-02.qua-prem-health.com"
alias ssh-paid-db-uat="ssh c-db-ph-02.premisehealth.com"
alias ssh-paid-db-prod="ssh p-db-ph-02.premisehealth.com"
alias ssh-peap-web-uat="ssh c-wb-l-peap-01.premisehealth.com"
alias ssh-peap-web-prod="ssh p-wb-l-peap-01.premisehealth.com"
alias ssh-peap-api-uat="ssh c-ap-l-peap-01.premisehealth.com"
alias ssh-peap-api-prod="ssh p-ap-l-peap-01.premisehealth.com"
alias ssh-peap-db-dev="ssh d-db-ph-02.dev-prem-health.com"
alias ssh-peap-db-qa="ssh q-db-ph-02.qua-prem-health.com"
alias ssh-peap-db-uat="ssh c-db-ph-02.premisehealth.com"
alias ssh-peap-db-prod="ssh p-db-ph-02.premisehealth.com"
alias ssh-pma-web-uat="ssh c-wb-l-pma-01.premisehealth.com"
alias ssh-pma-web-prod="ssh p-wb-l-pma-01.premisehealth.com"
alias ssh-pma-api-uat="ssh c-ap-l-pma-01.premisehealth.com"
alias ssh-pma-api-uat-t="ssh c-ap-l-pma-01.premisehealth.com"
alias ssh-pma-api-prod="ssh p-ap-l-pma-01.premisehealth.com"
alias ssh-pma-api-prod-t="ssh p-ap-l-pma-01t.premisehealth.com"
alias ssh-pma-db-dev="ssh d-db-ph-02.dev-prem-health.com"
alias ssh-pma-db-qa="ssh q-db-ph-02.qua-prem-health.com"
alias ssh-pma-db-uat="ssh c-db-ph-02.premisehealth.com"
alias ssh-pma-db-prod="ssh p-db-wrhouse-01.premisehealth.com"
alias ssh-ssoproxy-admin-web-uat="ssh c-wb-l-ohmsso-01.premisehealth.com"
alias ssh-ssoproxy-admin-web-prod="ssh p-wb-l-ohmsso-01.premisehealth.com"
alias ssh-ssoproxy-admin-api-uat="ssh c-wb-l-ohmsso-01.premisehealth.com"
alias ssh-ssoproxy-admin-api-prod="ssh p-wb-l-ohmsso-01.premisehealth.com"
alias ssh-ssoproxy-admin-db-dev="ssh d-db-ph-02.dev-prem-health.com"
alias ssh-ssoproxy-admin-db-qa="ssh q-db-ph-02.qua-prem-health.com"
alias ssh-ssoproxy-admin-db-uat="ssh c-db-ph-02.premisehealth.com"
alias ssh-ssoproxy-admin-db-prod="ssh p-db-ph-02.premisehealth.com"
alias ssh-ssoproxy-api-uat="ssh c-wb-l-ohmsso-01.premisehealth.com"
alias ssh-ssoproxy-api-prod="ssh p-wb-l-ohmsso-01.premisehealth.com"
alias ssh-ssoproxy-api-dev-db="ssh d-db-ph-02.dev-prem-health.com"
alias ssh-ssoproxy-api-qa-db="ssh q-db-ph-02.qua-prem-health.com"
alias ssh-ssoproxy-api-uat-db="ssh c-db-ph-02.premisehealth.com"
alias ssh-ssoproxy-api-prod-db="ssh p-db-ph-02.premisehealth.com"

## git aliases
alias groot='cd $(git rev-parse --show-toplevel 2>/dev/null || echo .)' # go to git root
alias glog="git log --graph --pretty=format:'%Cred%h%Creset %an: %s - %Creset %C(yellow)%d%Creset %Cgreen(%cr)%Creset' --abbrev-commit --date=relative" # pretty git log
alias gd='git diff --color | sed "s/^\([^-+ ]*\)[-+ ]/\\1/" | less -r' # colorized git diff in less
alias gs='git status -sb' # upgrade your git if -sb breaks for you. it's fun.
alias gfa='git fetch --all'
alias assume-unchanged='git update-index --assume-unchanged' # use this to ignore local changes to a file
alias assume-changed='git update-index --no-assume-unchanged' # use this to start tracking changes again
alias uncommitted='git diff --name-only' # list uncommitted files
alias last='git log -1 HEAD' # show last commit
alias amend='git commit --amend --no-edit' # quickly amend last commit without changing the message
alias lg='lazygit' # launch lazygit
alias gph='git push origin HEAD' # push current branch to origin (same as git push origin <current-branch>)
alias gmm='git merge master' # merge master into current branch

# termninal recording
alias record='asciinema rec -c "zsh" ~/code/asciinema/$(date +%Y-%m-%d_%H-%M-%S).cast' # record terminal session to a file in ~/code/asciinema
alias play='asciinema play' # play a recorded terminal session
alias listrecords='ls ~/code/asciinema' # list recorded terminal sessions
# Press Ctrl+D (or type exit and press Enter) in the terminal where you started the recording.
alias stoprecord='exit' # stop recording terminal session

# kap
alias kap='open -a Kap' # open kap app

# generate a new GUID and copy it to the clipboard
alias copyApiKey='file=$(find . -name "appsettings.Local.json" -not -path "*/bin/*" -not -path "*/obj/*" -print -quit) && jq -r ".ApiKey" "$file" | tr -d "\n" | tee >(pbcopy) && echo "API key copied to clipboard from $file."'