# Interactive container info viewer for klogs
klogs_container_info() {
  local pod="$1"
  local ns="$2"
  local container="$3"

  # ANSI color codes
  local RESET=$'\033[0m'
  local BOLD=$'\033[1m'
  local CYAN=$'\033[1;36m'
  local GREEN=$'\033[1;32m'
  local YELLOW=$'\033[1;33m'
  local MAGENTA=$'\033[1;35m'
  local BLUE=$'\033[1;34m'
  local RED=$'\033[1;31m'

  echo -e "\n${CYAN}========================================${RESET}"
  echo -e "${CYAN}Container Info:${RESET} ${GREEN}${container}${RESET}"
  echo -e "Pod: ${CYAN}${pod}${RESET}"
  echo -e "Namespace: ${CYAN}${ns}${RESET}"
  echo -e "${CYAN}========================================${RESET}"
  echo -e "Status: ${GREEN}Running${RESET}"
  echo -e "Ready: ${GREEN}True${RESET}"
  echo -e "Restart Count: ${YELLOW}0${RESET}"
  echo -e "Started At: ${BOLD}2025-09-15T17:25:49Z${RESET}"
  echo -e ""
  echo -e "Image: ${MAGENTA}premisehealth-dockerv2-local.jfrog.io/pma-api:master${RESET}"
  echo -e "Image ID: ${MAGENTA}premisehealth-dockerv2-local.jfrog.io/pma-api@sha256:316fa6811098f9181b100cacb9d34d79b0bc3e0360c63beaeaa65ae087fe74f8${RESET}"
  echo -e "Container ID: ${CYAN}containerd://12bc7113a3a03065c87c18e306a86dae57266c858ba8370daa3e6cc8a1948c84${RESET}"
  echo -e ""
  echo -e "Ports: ${YELLOW}8080/TCP${RESET}"
  echo -e ""
  echo -e "Environment Variables:"
  echo -e "  From ConfigMap: ${CYAN}pma-api-configmap${RESET}"
  echo -e "  DB_USER: <set from secret 'pma-db' key 'DB_USERNAME'>"
  echo -e "  DB_PASSWORD: <set from secret 'pma-db' key 'DB_PASSWORD'>"
  echo -e "  MSL_USER: <set from secret 'pma-msldb' key 'DB_USERNAME'>"
  echo -e "  MSL_PASSWORD: <set from secret 'pma-msldb' key 'DB_PASSWORD'>"
  echo -e ""
  echo -e "Mounts: ${CYAN}/var/run/secrets/kubernetes.io/serviceaccount${RESET} (from kube-api-access-q4p7d, ro)"
  echo -e ""
  echo -e "Pod IP: ${CYAN}172.20.10.217${RESET}"
  echo -e "Node: ${CYAN}dev-1e6936-worker-1/10.115.155.51${RESET}"
  echo -e "${CYAN}========================================${RESET}"

  # Interactive menu for more details
  while true; do
    echo -e "\n${BLUE}More Details (choose one to view, or exit):${RESET}"
    echo -e "${YELLOW}1.${RESET} View Pod Conditions (placeholder)"
    echo -e "${YELLOW}2.${RESET} View Volumes (placeholder)"
    echo -e "${YELLOW}3.${RESET} View Events (placeholder)"
    echo -e "${YELLOW}4.${RESET} View All Info (placeholder)"
    echo -e "${RED}5.${RESET} Exit"
    if [ -n "${ZSH_VERSION:-}" ]; then
      read "detail_choice?Enter the number of the detail to view (or 5 to exit): "
    else
      printf "Enter the number of the detail to view (or 5 to exit): "
      read -r detail_choice
    fi
    case "$detail_choice" in
      1)
        echo -e "\n${CYAN}Pod Conditions: [placeholder]${RESET}"
        ;;
      2)
        echo -e "\n${CYAN}Volumes: [placeholder]${RESET}"
        ;;
      3)
        echo -e "\n${CYAN}Events: [placeholder]${RESET}"
        ;;
      4)
        echo -e "\n${CYAN}All Info: [placeholder]${RESET}"
        ;;
      5)
        echo -e "${RED}Exiting container info view.${RESET}"
        break
        ;;
      *)
        echo -e "${RED}Invalid choice. Please enter a number from 1 to 5.${RESET}"
        ;;
    esac
  done
}
# Quick navigation aliases for dotfiles 
alias df='cd ~/dotfiles'
alias dotfiles='cd ~/dotfiles'

# Stream Kubernetes pod logs for an app.
klogs() {
  # Defaults
  local KLOG_NO_COLOR=0
  local KLOG_LINES=""
  local KLOG_SEARCH_TERMS=()
  local KLOG_APP=""

  # Parse all arguments, flags can be anywhere
  while [ "$#" -gt 0 ]; do
    echo "[DEBUG] Parsing arg: $1"
    case "$1" in
      -n|--no-color)
        KLOG_NO_COLOR=1
        shift
        ;;
      -l|--lines)
        shift
        if [ -n "$1" ] && printf '%s' "$1" | grep -qE '^[0-9]+$'; then
          KLOG_LINES="$1"
          shift
        else
          echo "Error: --lines requires a numeric argument"
          return 1
        fi
        ;;
      --lines=*)
        KLOG_LINES="${1#--lines=}"
        shift
        ;;
      -s|--search)
        shift
        if [ -n "$1" ]; then
          KLOG_SEARCH_TERMS+=("$1")
          shift
        else
          echo "Error: --search requires an argument"
          return 1
        fi
        ;;
      --search=*)
        KLOG_SEARCH_TERMS+=("${1#--search=}")
        shift
        ;;
      -h|--help)
        cat <<EOF
klogs - Stream Kubernetes pod logs for an app, with interactive pod selection and advanced filtering.

USAGE:
  klogs [ -n | --no-color ] [ -l N | --lines N ] [ -s TERM | --search TERM ]... <app-name>

FLAGS:
  -n, --no-color         Disable colored output in pod list and logs
  -l N, --lines N        Tail last N lines before streaming logs (default: all)
  -s TERM, --search TERM Filter logs for TERM (case-insensitive, fixed string). Repeat for multiple terms.
  -h, --help             Show this help guide

ARGUMENTS:
  <app-name>             Required. Substring to match pod names (e.g., sso-proxy)

EXAMPLES:
  klogs sso-proxy                      # Stream all logs for pods matching 'sso-proxy'
  klogs -l 200 sso-proxy               # Tail last 200 lines, then follow logs
  klogs -s error sso-proxy             # Show only log lines containing 'error'
  klogs -s error -s warning sso-proxy  # Show log lines containing 'error' OR 'warning'
  klogs -n -l 100 -s foo sso-proxy     # Disable color, tail 100 lines, filter 'foo'
  klogs sso-proxy 200                  # (Legacy) Tail 200 lines for 'sso-proxy'
  klogs sso-proxy error                # (Legacy) Filter logs for 'error'

LOG DATA EXAMPLE:
  10.115.155.14 - - [10/Oct/2025:17:01:00 +0000] "GET /api/status HTTP/1.1" 200 60 "-" "curl/7.61.1" "-"

SEARCHING FOR LOGS FROM A SPECIFIC HOUR ON A DATE:
  To show all logs from 17:00 on 10/Oct/2025:
    klogs sso-proxy -s 10/Oct/2025:17
  To show logs from multiple hours or dates:
    klogs sso-proxy -s 10/Oct/2025:17 -s 10/Oct/2025:18

INTERACTIVE POD SELECTION:
  - Lists all pods matching <app-name> across namespaces
  - Shows pod info in a table (unless --no-color)
  - Prompts for pod selection by number

LOG STREAMING:
  - Streams logs for the selected pod
  - If --lines is set, tails last N lines before following
  - If --search is set, filters logs for TERM(s) (case-insensitive)
  - Color highlighting for TERM(s) if color enabled

TROUBLESHOOTING:
  - If no pods are found, check your app name or namespace
  - If you see 'No pods found', verify kubectl context and permissions
  - For very large logs, use --lines to limit output

TIPS:
  - Flags can appear before or after <app-name>
  - Works in both zsh and bash
  - Backwards-compatible with simple forms: klogs app 200, klogs app error
  - Use --no-color for piping output to files or other tools

EOF
        return 0
        ;;
      --)
        shift
        break
        ;;
      -* )
        echo "Unknown option: $1"
        return 1
        ;;
      *)
        if [ -z "$KLOG_APP" ]; then
          KLOG_APP="$1"
          shift
        elif [ -z "$KLOG_LINES" ] && printf '%s' "$1" | grep -qE '^[0-9]+$'; then
          KLOG_LINES="$1"
          shift
        elif [ -z "$KLOG_SEARCH_TERM" ]; then
          KLOG_SEARCH_TERM="$1"
          shift
        else
          shift
        fi
        ;;
    esac
  done

  echo "[DEBUG] After flag parsing: KLOG_NO_COLOR=$KLOG_NO_COLOR, KLOG_LINES=$KLOG_LINES, KLOG_SEARCH_TERM=$KLOG_SEARCH_TERM, app=\"$KLOG_APP\""
  if [ -z "$KLOG_APP" ]; then
    echo "Usage: klogs [ -n | --no-color ] [ -l N | --lines N ] [ -s TERM | --search TERM ] <app-name>"
    return 1
  fi

  # Colors (zsh/bash compatible) - only set when coloring enabled
  if [ "$KLOG_NO_COLOR" -eq 0 ]; then
    local RESET=$'\033[0m'
    local BOLD=$'\033[1m'
    local CYAN=$'\033[36m'    # namespace
    local GREEN=$'\033[32m'   # pod name
    local YELLOW=$'\033[33m'  # ready/status
    local HEADER_COLOR=$'\033[97m'
  else
    local RESET=''
    local BOLD=''
    local CYAN=''
    local GREEN=''
    local YELLOW=''
    local HEADER_COLOR=''
  fi

  # Get pods output, filter by pod name, and keep header; keep alignment with column -t
  pods_raw=$(kubectl get pods --all-namespaces | grep -E "^NAMESPACE|$KLOG_APP" | column -t 2>/dev/null)
  if [ -z "$pods_raw" ]; then
    echo "No pods found matching name: $KLOG_APP."
    return 1
  fi

  header=$(echo "$pods_raw" | head -n 1)
  pods=$(echo "$pods_raw" | tail -n +2)

  pod_lines=()
  while IFS= read -r line; do
    [[ -n "$line" ]] && pod_lines+=("$line")
  done <<< "$pods"

  if [ ${#pod_lines[@]} -eq 0 ]; then
    echo "No pods found matching name: $KLOG_APP."
    return 1
  fi

  # Color header labels (preserve spacing)
  colored_header=$(printf "%s" "$header" | sed -E \
    -e "s/\bNAMESPACE\b/${BOLD}${CYAN}&${RESET}/g" \
    -e "s/\bNAME\b/${BOLD}${GREEN}&${RESET}/g" \
    -e "s/\bREADY\b/${BOLD}${YELLOW}&${RESET}/g" \
    -e "s/\bSTATUS\b/${BOLD}${YELLOW}&${RESET}/g")

  printf "\n%-4s %s\n" "Idx" "$colored_header"
  # Iterate safely over indices
  i=1
  for raw_line in "${pod_lines[@]}"; do
    # Preserve the exact spacing between columns by capturing separators.
    # Capture: optional leading spaces, col1, separator spaces, col2, rest
    colored_line=$(printf "%s" "$raw_line" | sed -E \
      -e "s/^([[:space:]]*)([^[:space:]]+)([[:space:]]+)([^[:space:]]+)(.*)$/\\1${CYAN}\\2${RESET}\\3${GREEN}\\4${RESET}\\5/")
    printf "[%-2d] %s\n" "$i" "$colored_line"
    i=$((i+1))
  done

  # Prompt for selection in a shell-compatible way. Use zsh-style prompt when
  # running under zsh, otherwise fall back to a POSIX read prompt so this
  # function works both in zsh and bash.
  if [ -n "${ZSH_VERSION:-}" ]; then
    read "idx?Enter the number of the pod: "
  else
    printf "Enter the number of the pod: "
    read -r idx
  fi
  if ! [[ "$idx" =~ ^[0-9]+$ ]]; then
    echo "Please enter a valid number."
    return 1
  fi
  if [ "$idx" -lt 1 ] || [ "$idx" -gt ${#pod_lines[@]} ]; then
    echo "Please select a valid pod number."
    return 1
  fi

  # zsh arrays are 1-based while bash arrays are 0-based. Select the
  # appropriate element depending on the running shell.
  if [ -n "${ZSH_VERSION:-}" ]; then
    selected="${pod_lines[$idx]}"
  else
    selected="${pod_lines[$((idx-1))]}"
  fi
  ns=$(echo "$selected" | awk '{print $1}')
  pod=$(echo "$selected" | awk '{print $2}')

  if [ -z "$ns" ] || [ -z "$pod" ]; then
    echo "Invalid selection."
    return 1
  fi

  # Get container names for the selected pod
  if [ -n "${ZSH_VERSION:-}" ]; then
    typeset -a container_names
    container_names=( $(kubectl get pod "$pod" -n "$ns" -o jsonpath='{.spec.containers[*].name}') )
  else
    local container_names=( $(kubectl get pod "$pod" -n "$ns" -o jsonpath='{.spec.containers[*].name}') )
  fi
  echo "[DEBUG] container_names: ${container_names[@]}"
  selected_container="${container_names[0]}"
  if [ ${#container_names[@]} -gt 1 ]; then
    echo "\nThis pod has multiple containers:"
    idx=1
    for name in "${container_names[@]}"; do
      printf "[%d] %s\n" "$idx" "$name"
      idx=$((idx+1))
    done
    echo ""
    echo "Choose an action:"
    echo "[L] View logs for a container"
    echo "[I] View info about a container"
    if [ -n "${ZSH_VERSION:-}" ]; then
      read "action?Enter L for logs or I for info (default L): "
    else
      printf "Enter L for logs or I for info (default L): "
      read -r action
    fi
    action="${action:-L}"
    if [[ "$action" =~ ^[Ii]$ ]]; then
      if [ -n "${ZSH_VERSION:-}" ]; then
        read "cidx?Enter the number of the container to view info (default 1): "
      else
        printf "Enter the number of the container to view info (default 1): "
        read -r cidx
      fi
      echo "[DEBUG] cidx: $cidx"
      if [[ "$cidx" =~ ^[0-9]+$ ]] && [ "$cidx" -ge 1 ] && [ "$cidx" -le ${#container_names[@]} ]; then
        idx=1
        for name in "${container_names[@]}"; do
          if [ "$idx" -eq "$cidx" ]; then
            selected_container="$name"
            break
          fi
          idx=$((idx+1))
        done
      fi
      echo "[DEBUG] selected_container: $selected_container"
      klogs_container_info "$pod" "$ns" "$selected_container"
      return 0
    fi
    if [ -n "${ZSH_VERSION:-}" ]; then
      read "cidx?Enter the number of the container to view logs (default 1): "
    else
      printf "Enter the number of the container to view logs (default 1): "
      read -r cidx
    fi
    echo "[DEBUG] cidx: $cidx"
    if [[ "$cidx" =~ ^[0-9]+$ ]] && [ "$cidx" -ge 1 ] && [ "$cidx" -le ${#container_names[@]} ]; then
      idx=1
      for name in "${container_names[@]}"; do
        if [ "$idx" -eq "$cidx" ]; then
          selected_container="$name"
          break
        fi
        idx=$((idx+1))
      done
    fi
    echo "[DEBUG] selected_container: $selected_container"
  fi

  # Build kubectl command and optionally filter by search term using grep.
  if [ -n "$KLOG_LINES" ]; then
    kub_cmd=(kubectl logs -n "$ns" "$pod" -c "$selected_container" --tail="$KLOG_LINES" -f)
    echo "Streaming last $KLOG_LINES lines for pod $pod (container $selected_container) in namespace $ns..."
  else
    kub_cmd=(kubectl logs -n "$ns" "$pod" -c "$selected_container" -f)
    echo "Streaming all logs for pod $pod (container $selected_container) in namespace $ns..."
  fi

  if [ ${#KLOG_SEARCH_TERMS[@]} -gt 0 ]; then
    # Build grep arguments for all search terms
    grep_args=(--line-buffered -i -F)
    if [ "$KLOG_NO_COLOR" -eq 0 ]; then
      grep_args+=(--color=always)
    fi
    for term in "${KLOG_SEARCH_TERMS[@]}"; do
      grep_args+=(-e "$term")
    done
    "${kub_cmd[@]}" | grep "${grep_args[@]}"
  else
    "${kub_cmd[@]}"
  fi
}
# Usage examples:
#   klogs sso-proxy            # stream all logs for app pods
#   klogs sso-proxy 200        # stream last 200 lines then follow
#   klogs sso-proxy error      # stream logs and show only lines containing 'error'
#   klogs -n sso-proxy 200 foo # disable coloring, tail 200 lines, filter 'foo'

# Function to check dotfiles status (git and Brewfile)
_check_dotfiles_status() {
  local show_success="${1:-false}"
  local in_dotfiles_dir="${2:-false}"
  local check_session_warn="${3:-false}"
  
  if [ "$in_dotfiles_dir" = "false" ]; then
    cd ~/dotfiles
  fi
  
  local issues_found=false
  
  if [[ -d ".git" ]]; then
    changes=$(git status --porcelain | wc -l)
    changes="${changes##*( )}"
    changes="${changes%%*( )}"
    if [ "$changes" -gt 0 ]; then
      # Only show if not checking session warning, or if we haven't warned in this session
      if [ "$check_session_warn" = "false" ] || [[ "$_DOTFILES_RELOAD_WARN" != "$$" ]]; then
        print -P "%F{yellow} $changes uncommitted change(s) in ~/dotfiles. Use 'dotpush'.%f"
        issues_found=true
      fi
    fi
  fi
  
  if ! brew bundle check --file="$HOME/dotfiles/Brewfile" &>/dev/null; then
    print -P "%F{yellow} Your Brewfile is out of sync with installed packages.%f"
    print -P "%F{cyan} Use 'brewupdate' to update your Brewfile, run 'brew outdated' to see what is outdated.%f"
    issues_found=true
  fi
  
  if [ "$show_success" = "true" ] && [ "$issues_found" = "false" ]; then
    print -P "%F{green} âœ“ Dotfiles are up to date - no uncommitted changes and Brewfile is in sync.%f"
  fi
  
  if [ "$in_dotfiles_dir" = "false" ]; then
    cd - > /dev/null
  fi
  
  return $([ "$issues_found" = "true" ] && echo 1 || echo 0)
}

# Check dotfiles status - shows git and Brewfile warnings if needed
alias df-check='_check_dotfiles_status true false'

# Show what changes would be committed in dotfiles using smart commit message
alias df-diff='cd ~/dotfiles && echo "=== Git Status ===" && git status --short && echo && echo "=== Proposed Commit Message ===" && (git genmsg) && cd -'
# Custom Aliases for Zsh

# quick alias to add, commit, and push all changes in dotfiles
alias dotpush='cd ~/dotfiles && git genmsg --commit --all && git push && cd -'

# preview the commit message that dotpush would use without committing
alias dotpush-dryrun='cd ~/dotfiles && git genmsg && cd -'

# quick alias to update Brewfile with current Homebrew/cask/extensions
# Usage: Run 'brewupdate' to update and overwrite Brewfile with your current setup
alias brewupdate='brew update && brew upgrade && brew bundle dump --file=~/dotfiles/Brewfile --force'

## aliases
alias ip='ipconfig getifaddr en0' # get local IP address
## 1Password ssh-agent aliases
# list ssh keys added to the 1Password ssh-agent
alias 1pass-ssh-list='SSH_AUTH_SOCK=~/Library/Group\ Containers/2BUA8C4S2C.com.1password/t/agent.sock ssh-add -l'
# open the 1Password ssh-agent config file
alias 1pass-ssh-config='open ~/.config/1Password/ssh/agent.toml'

# GPG key management
alias gpg-list='gpg --list-secret-keys --keyid-format LONG'
alias gpg-list-all='gpg --list-keys --keyid-format LONG'
alias gpg-github='_gpg_github_format'
alias gpg-gitlab='_gpg_gitlab_format'
alias gpg-find='_gpg_find'
alias gpg-export='_gpg_export'
alias gpg-fingerprint='gpg --fingerprint'

# GPG helper functions
_gpg_github_format() {
    gpg --list-secret-keys --keyid-format LONG | awk '
    /^sec/ {
        # Extract key ID from sec line
        split($2, parts, "/")
        keyid = parts[2]
        stored_keyid = keyid
    }
    /^uid/ {
        # Extract email from uid line and print first with light blue color
        match($0, /<[^>]+>/)
        echo "[DEBUG] Presenting options for commit_msg: $commit_msg"
        if (RSTART) {
            email = substr($0, RSTART+1, RLENGTH-2)
            printf "Email address: \033[94m%s\033[0m\n", email
            print "Key ID: " stored_keyid
        }
        echo "[DEBUG] User selected: $choice"
    }
    /^ssb/ {
        # Extract subkey ID from ssb line
        split($2, parts, "/")
        subkeyid = parts[2]
        print "Subkeys: " subkeyid
        print ""  # Empty line between keys
    }'
}

_gpg_gitlab_format() {
    gpg --list-secret-keys --with-subkey-fingerprints --keyid-format LONG | awk '
    BEGIN { 
        main_fingerprint = ""
        email = ""
        subkey_fingerprints = ""
        processing_main = 0
    }
    /^sec/ {
        processing_main = 1
    }
    /^uid/ {
        # Extract email from uid line
        match($0, /<[^>]+>/)
        if (RSTART) {
            email = substr($0, RSTART+1, RLENGTH-2)
        }
        processing_main = 0
    }
    /^ssb/ {
        processing_main = 0
    }
    /^      [A-F0-9]{40}$/ {
        # This is a fingerprint line (40 hex characters)
        if (processing_main) {
            main_fingerprint = $1
            processing_main = 0
        } else {
            # This is a subkey fingerprint
            if (subkey_fingerprints == "") {
                subkey_fingerprints = $1
            } else {
                subkey_fingerprints = subkey_fingerprints "\n" $1
            }
        }
    }
    END {
        if (email != "" && main_fingerprint != "") {
            printf "Email address: \033[94m%s\033[0m\n", email
            print "Key ID: " main_fingerprint
            if (subkey_fingerprints != "") {
                print "Subkeys: " subkey_fingerprints
            }
            print ""
        }
    }'
}

_gpg_find() {
    if [ $# -eq 0 ]; then
        echo "Usage: gpg-find <email|keyid|name>"
        return 1
    fi
    echo "Searching for: $1"
    gpg --list-secret-keys --keyid-format LONG | grep -i -A 3 -B 1 "$1"
}

_gpg_export() {
    if [ $# -eq 0 ]; then
        echo "Usage: gpg-export <keyid>"
        echo "This will export the public key for adding to GitHub/services"
        return 1
    fi
    echo "Public key for $1:"
    echo "=========================="
    gpg --armor --export "$1"
}

## copilot aliases
# alias to show directory info, git status, and git directories
alias info='echo "Current directory: $(pwd)"; echo; if git rev-parse --is-inside-work-tree &>/dev/null; then echo "This directory is a git repository."; else echo "This directory is NOT a git repository."; fi; echo; echo "Other .git directories under this tree:"; find . -type d -name .git | tee >(wc -l | awk '\''{print "Total: " $1}'\'')'

## ssh aliases
alias ssh-bitbucket="ssh bitbucket.org"
alias ssh-github="ssh github.com"
alias ssh-jenkins="ssh jenkins.premisehealth.com"
alias ssh-extract-api-dev="ssh d-ap-l-extract-02.premisehealth.com"
alias ssh-extract-api-qa="ssh q-ap-l-extract-01.premisehealth.com"
alias ssh-extract-api-prod="ssh p-ap-l-extract-02.premisehealth.com"
alias ssh-extract-db-dev="ssh d-db-tal-01.premisehealth.com"
alias ssh-extract-db-qa="ssh q-db-tal-01.premisehealth.com"
alias ssh-extract-db-prod="ssh p-db-tal-01.premisehealth.com"
alias ssh-paid-web-uat="ssh c-ap-l-paid-01.premisehealth.com"
alias ssh-paid-web-prod="ssh p-ap-l-paid-01.premisehealth.com"
alias ssh-paid-api-uat="ssh c-ap-l-paid-01.premisehealth.com"
alias ssh-paid-api-prod="ssh p-ap-l-paid-01.premisehealth.com"
alias ssh-paid-db-dev="ssh d-db-ph-02.dev-prem-health.com"
alias ssh-paid-db-qa="ssh q-db-ph-02.qua-prem-health.com"
alias ssh-paid-db-uat="ssh c-db-ph-02.premisehealth.com"
alias ssh-paid-db-prod="ssh p-db-ph-02.premisehealth.com"
alias ssh-peap-web-uat="ssh c-wb-l-peap-01.premisehealth.com"
alias ssh-peap-web-prod="ssh p-wb-l-peap-01.premisehealth.com"
alias ssh-peap-api-uat="ssh c-ap-l-peap-01.premisehealth.com"
alias ssh-peap-api-prod="ssh p-ap-l-peap-01.premisehealth.com"
alias ssh-peap-db-dev="ssh d-db-ph-02.dev-prem-health.com"
alias ssh-peap-db-qa="ssh q-db-ph-02.qua-prem-health.com"
alias ssh-peap-db-uat="ssh c-db-ph-02.premisehealth.com"
alias ssh-peap-db-prod="ssh p-db-ph-02.premisehealth.com"
alias ssh-pma-web-uat="ssh c-wb-l-pma-01.premisehealth.com"
alias ssh-pma-web-prod="ssh p-wb-l-pma-01.premisehealth.com"
alias ssh-pma-api-uat="ssh c-ap-l-pma-01.premisehealth.com"
alias ssh-pma-api-uat-t="ssh c-ap-l-pma-01.premisehealth.com"
alias ssh-pma-api-prod="ssh p-ap-l-pma-01.premisehealth.com"
alias ssh-pma-api-prod-t="ssh p-ap-l-pma-01t.premisehealth.com"
alias ssh-pma-db-dev="ssh d-db-ph-02.dev-prem-health.com"
alias ssh-pma-db-qa="ssh q-db-ph-02.qua-prem-health.com"
alias ssh-pma-db-uat="ssh c-db-ph-02.premisehealth.com"
alias ssh-pma-db-prod="ssh p-db-wrhouse-01.premisehealth.com"
alias ssh-ssoproxy-admin-web-uat="ssh c-wb-l-ohmsso-01.premisehealth.com"
alias ssh-ssoproxy-admin-web-prod="ssh p-wb-l-ohmsso-01.premisehealth.com"
alias ssh-ssoproxy-admin-api-uat="ssh c-wb-l-ohmsso-01.premisehealth.com"
alias ssh-ssoproxy-admin-api-prod="ssh p-wb-l-ohmsso-01.premisehealth.com"
alias ssh-ssoproxy-admin-db-dev="ssh d-db-ph-02.dev-prem-health.com"
alias ssh-ssoproxy-admin-db-qa="ssh q-db-ph-02.qua-prem-health.com"
alias ssh-ssoproxy-admin-db-uat="ssh c-db-ph-02.premisehealth.com"
alias ssh-ssoproxy-admin-db-prod="ssh p-db-ph-02.premisehealth.com"
alias ssh-ssoproxy-api-uat="ssh c-wb-l-ohmsso-01.premisehealth.com"
alias ssh-ssoproxy-api-prod="ssh p-wb-l-ohmsso-01.premisehealth.com"
alias ssh-ssoproxy-api-dev-db="ssh d-db-ph-02.dev-prem-health.com"
alias ssh-ssoproxy-api-qa-db="ssh q-db-ph-02.qua-prem-health.com"
alias ssh-ssoproxy-api-uat-db="ssh c-db-ph-02.premisehealth.com"
alias ssh-ssoproxy-api-prod-db="ssh p-db-ph-02.premisehealth.com"

## git aliases
alias groot='cd $(git rev-parse --show-toplevel 2>/dev/null || echo .)' # go to git root
alias glog="git log --graph --pretty=format:'%Cred%h%Creset %an: %s - %Creset %C(yellow)%d%Creset %Cgreen(%cr)%Creset' --abbrev-commit --date=relative" # pretty git log
alias gd='git diff --color | sed "s/^\([^-+ ]*\)[-+ ]/\\1/" | less -r' # colorized git diff in less
alias gs='git status -sb' # upgrade your git if -sb breaks for you. it's fun.
alias gfa='git fetch --all'
alias assume-unchanged='git update-index --assume-unchanged' # use this to ignore local changes to a file
alias assume-changed='git update-index --no-assume-unchanged' # use this to start tracking changes again
alias uncommitted='git diff --name-only' # list uncommitted files
alias last='git log -1 HEAD' # show last commit
alias amend='git commit --amend --no-edit' # quickly amend last commit without changing the message
alias lg='lazygit' # launch lazygit
alias gph='git push origin HEAD' # push current branch to origin (same as git push origin <current-branch>)
alias gmm='git merge master' # merge master into current branch

# termninal recording
alias record='asciinema rec -c "zsh" ~/code/asciinema/$(date +%Y-%m-%d_%H-%M-%S).cast' # record terminal session to a file in ~/code/asciinema
alias play='asciinema play' # play a recorded terminal session
alias listrecords='ls ~/code/asciinema' # list recorded terminal sessions
# Press Ctrl+D (or type exit and press Enter) in the terminal where you started the recording.
alias stoprecord='exit' # stop recording terminal session

# kap
alias kap='open -a Kap' # open kap app

# generate a new GUID and copy it to the clipboard
alias copyApiKey='file=$(find . -name "appsettings.Local.json" -not -path "*/bin/*" -not -path "*/obj/*" -print -quit) && jq -r ".ApiKey" "$file" | tr -d "\n" | tee >(pbcopy) && echo "API key copied to clipboard from $file."'